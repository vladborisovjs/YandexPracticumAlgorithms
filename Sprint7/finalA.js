// 73581410
/**
 * ПРИНЦИП РАБОТЫ
 *   1. Заводим массив dp и будем в i,j хранить минимальное кол-во операции
 *   2. Базовый случай. Пустые строки
 *     dp[0][0] = 0
 *     dp[0][j] = j
 *     dp[i][0] = i
 *   3. Переход динамики
 *     Если последние символы префиксов равны
 *     dp[i][j] = dp[i - 1][j - 1]
 *     Иначе мы вибираем из 3х возможных вариантов
 *     dp[i - 1][j - 1] - значение ячейки выше и слева от текущей + 1
 *     dp[i][j - 1] - значение ячейки слева от текущей + 1
 *     dp[i - 1][j] - значение ячейки выше от текущей + 1
 *   4. Порядок вычисления сверху - вниз, слева - направо
 *   5. Результат в нижнем правом углу матрицы
 * ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ
 *   Алгоритм делает сравнения каждого префикса одной с префиксом другой строки.
 *   После полного сравнения всех символов из 2х строк мы можем достать минимальное расстояние в dp[n][m]
 * ВРЕМЕННАЯ СЛОЖНОСТЬ
 *   O(N*M),
 *   N - где длина первой последовательности,
 *   M - где длина второй последовательности
 * ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ
 *   Храним расчеты в массиве n + 1 => O(N)
 * */
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

const input = [];
rl.on('line', line => {
    input.push(line);
    if (input.length === 2) {
        const s1 = input[0];
        const s2 = input[1];
        const n = s1.length;
        const m = s2.length;
        const dp = Array.from(
            Array(n + 1),
            () => Array(m + 1))

        for (let i = 0; i <= n; i++) {
            for (let j = 0; j <= m; j++) {
                if (i === 0 || j === 0) {
                    dp[i][j] = i + j;
                } else if (s1[i - 1] === s2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1
                }
            }
        }
        console.log(dp[n][m]);
        rl.close();
    }
})